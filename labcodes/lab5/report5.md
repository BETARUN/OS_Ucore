# 实验六：用户进程管理

17343025 冯浚轩 软件工程1班

同步到[GitHub](https://github.com/sky-5462/OS_Ucore)

## 实验目的

- 了解第一个用户进程创建过程
- 了解系统调用框架的实现机制
- 了解ucore如何实现系统调用sys_fork/sys_exec/sys_exit/sys_wait来进行进程管理

## 实验要求

实验4完成了内核线程，但到目前为止，所有的运行都在内核态执行。实验5将创建用户进程，让用户进程在用户态执行，且在需要ucore支持时，可通过系统调用来让ucore提供服务。为此需要构造出第一个用户进程，并通过系统调用sys_fork/sys_exec/sys_exit/sys_wait来支持运行不同的应用程序，完成对用户进程的执行过程的基本管理

## 实验方案

接着填写已有实验，并完成练习，注意对前面的实验可能需要进行修改来让内核正常工作

## 实验过程

### 练习1：加载应用程序并执行

`do_execve()`函数用于加载应用程序，该函数调用`exit_mmap()`函数和`put_pgdir()`函数回收当前进程的内存资源，然后调用`load_icode()`来加载并解析一个处于内存中的ELF执行文件格式的应用程序，改函数的主要工作是分配应用程序需要的内存空间

1. 分配内存管理块`mm_struct`
2. 分配页目录和页表
3. 解析ELF文件得到各个段的信息，为各个段分配内存，拷贝ELF文件中各个段的内容到新分配的内存中
4. 建立用户栈
5. 将进程控制块中关于内存管理块`mm_struct`和页目录基址`pgdir`的项设定为新进程的值，完成内存管理的切换
6. 设置中断帧为新进程的相关内容，当前进程加载成为新进程后需要从特权模式切换回用户模式，在这里需要正确设置中断帧让中断恢复正常进行

最后将进程控制块中的进程名设为新进程的名称，当前进程就完全被替换为新进程了，可以等待调度切换

其中我需要完成对中断帧的设置，具体如下：

```c
tf->tf_cs = USER_CS;
tf->tf_ds = tf->tf_es = tf->tf_ss = USER_DS;
tf->tf_esp = USTACKTOP;
tf->tf_eip = elf->e_entry;
tf->tf_eflags = FL_IF;
```

在中断帧中设定各个段寄存器用于段，设置栈寄存器`esp`为用户栈栈顶，设置指令寄存器`eip`为新加载应用程序的入口地址，设置状态寄存器`eflags`让CPU在用户态下可以接收中断

---

回答问题：**当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的**

查看`do_execve()`函数的调用链条如下：`SYS_exec`系统调用 -> `sys_exer()`函数 -> `do_execve()`函数

`do_execve()`函数结束后，新的应用程序已经被加载，需要从系统调用返回，由于我们设置好了中断帧，在从系统调用返回后会从内核态切换到用户态，并在新的应用程序的入口处开始执行

### 练习2：父进程复制自己的内存空间给子进程



---

回答问题：**如何设计实现“Copy on Write"机制”**


### 练习3：阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现



---

回答问题：

- **请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？**
- **请给出ucore中一个用户态进程的执行状态生命周期图**



### 实验结果


## 实验总结和对比

### 对比答案说明差异


### 本实验中重要的知识点


### OS原理中很重要但实验中没有对应的知识点

### 总结


## 参考文献

- [实验指导手册](https://github.com/chyyuu/ucore_os_docs/blob/master/SUMMARY.md)
